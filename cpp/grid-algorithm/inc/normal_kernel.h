#include <cuda_runtime.h>

#ifndef NORMAL_KERNEL_H
#define NORMAL_KERNEL_H

__global__ void setup_kernel(curandState *state)
{
  /*
  In CUDA programming, each thread has its own RNG state, which determines the
  sequence of random numbers generated by that thread. By initializing the RNG
  state, we ensure that each thread starts with a distinct and independent
  sequence of random numbers.
  */
    int id = threadIdx.x + blockIdx.x * blockDim.x;
    curand_init(42, id, 0, &state[id]);
}

__global__ void generate_normal_kernel(curandState *state,
                                unsigned int n,
                                float mu,
                                float sigma,
                                float *result)
{
    /*
    In this function we will be generating radom variates with curand_normal
    using the states defined in `setup_kernel`.
    */
    int index = threadIdx.x + blockIdx.x * blockDim.x;
    int stride = blockDim.x * gridDim.x;

    float rv;

    /* Generate pseudo-random normals */
    for(int i = index; i < n; i += stride) {
      /* Copy state to local memory for efficiency */
      curandState localState = state[index];

      rv = curand_normal(&localState);
      result[i] = mu + sigma * rv;

      /* Copy state back to global memory */
      state[i] = localState;  // TODO: this might not be necessary
    }
}

void generateNormalCuda(unsigned int n, float mu, float sigma, float *observations) {
  const unsigned int threadsPerBlock = 64;
  const unsigned int numBlocks = (n + threadsPerBlock  -1) / threadsPerBlock;

  curandState *devStates;

  // We need to assign states to each thread.
  cudaMallocManaged(&devStates, threadsPerBlock * numBlocks * sizeof(curandState));

  setup_kernel<<<numBlocks, threadsPerBlock>>>(devStates);

  generate_normal_kernel<<<numBlocks, threadsPerBlock>>>(
    devStates, n, mu, sigma, observations
  );

  cudaDeviceSynchronize();

  // Clean up
  cudaFree(devStates);
}

#endif