#include <iostream>
#include <math.h>  // C std library
#include <curand.h>
#include <curand_kernel.h>


// this is a macro, like a decorator
#define CUDA_CALL(x) do { if((x) != cudaSuccess) { \
    printf("Error at %s:%d\n",__FILE__,__LINE__); \
    return EXIT_FAILURE;}} while(0)

/*
Sources:
https://developer.nvidia.com/blog/efficient-cuda-debugging-memory-initialization-and-thread-synchronization-with-nvidia-compute-sanitizer/

https://docs.nvidia.com/cuda/curand/group__DEVICE.html

https://chat.openai.com/c/ba212caf-491f-4dfd-ac4f-ce2132672561

TODO: Move them to a note on obsidian once we are done along with the learnings
*/

__global__ void setup_kernel(curandState *state)
{
  /*
  In CUDA programming, each thread has its own RNG state, which determines the
  sequence of random numbers generated by that thread. By initializing the RNG 
  state, we ensure that each thread starts with a distinct and independent 
  sequence of random numbers.
  */
    int id = threadIdx.x + blockIdx.x * blockDim.x;
    curand_init(42, id, 0, &state[id]);
}

__global__ 
void generateRandomVariates(float* randomNumbers, float mean, float stdev) {
  int index = blockIdx.x * blockDim.x + threadIdx.x;

  curandState_t state;  // init the state var
  curand_init(42, index, 0, &state);

  randomNumbers[index] = curand_normal(&state);
}

__global__ void generate_normal_kernel(curandState *state,
                                int n,
                                unsigned int *result)
{
    /* 
    In this function we will be generating radom variates in pairs with 
    curand_normal2 using the states defined in `setup_kernel`.
    */
    int id = threadIdx.x + blockIdx.x * blockDim.x;
    unsigned int count = 0;

    float2 x;  // define a pair of floats for curand_normal2
    
    /* Copy state to local memory for efficiency */
    curandState localState = state[id];
    
    /* Generate pseudo-random normals */
    for(int i = 0; i < n/2; i++) {
        x = curand_normal2(&localState);
        /* Check if within one standard deviaton */
        if((x.x > -1.0) && (x.x < 1.0)) {
            count++;
        }
        if((x.y > -1.0) && (x.y < 1.0)) {
            count++;
        }
    }

    /* Copy state back to global memory */
    state[id] = localState;
    
    /* Store results */
    result[id] += count;
}


int main(void)
{
  const unsigned int threadsPerBlock = 64;
  const unsigned int blockCount = 64;
  const unsigned int totalThreads = threadsPerBlock * blockCount;  // 4096

  float mu = 20.0f;
  float sigma = 2.0f;
  int numElements = 50;
  curandState *devStates;
  unsigned int *devResults, *hostResults;


  /* MEMORY ALLOCATION */
  // TODO: change this to cudaMallocManaged once is working

  /* Allocate space for results on host */
  hostResults = (unsigned int *)calloc(totalThreads, sizeof(int));

  /* Allocate space for prng states on device */
  CUDA_CALL(
    cudaMalloc((void **)&devStates, totalThreads *sizeof(curandState))
  );

  /* Allocate space for results on device */
  CUDA_CALL(cudaMalloc((void **)&devResults, totalThreads *
            sizeof(unsigned int)));

  /* Set results to 0 */
  CUDA_CALL(cudaMemset(devResults, 0, totalThreads *
            sizeof(unsigned int)));

  setup_kernel<<<blockCount, threadsPerBlock>>>(devStates);

  generate_normal_kernel<<<blockCount, threadsPerBlock>>>(
    devStates, numElements, devResults
  );

  cudaDeviceSynchronize();

  /* Copy device memory to host */
  CUDA_CALL(cudaMemcpy(hostResults, devResults, totalThreads *
      sizeof(unsigned int), cudaMemcpyDeviceToHost));

  // std::cout << "Generated numbers: " << std::endl;
  // for (int i = 0; i < numElements; i++) {
  //   std::cout << randomNumbers[i] << std::endl;
  // }
  // std::cout << "first number" << randomNumbers[0] << std::endl;
  std::cout << "Mean: " << mu << std::endl;
  std::cout << "Stdev: " << sigma << std::endl;
  std::cout << "Number of elements: " << numElements << std::endl;

  /* Show result */
  unsigned int total;
  int i;
  total = 0;
  for(i = 0; i < totalThreads; i++) {
      total += hostResults[i];
  }
  printf("Fraction of normals within 1 standard deviation was %10.13f\n",
      (float)total / (totalThreads * numElements * 50.0f));
 
  CUDA_CALL(cudaFree(devStates));
  CUDA_CALL(cudaFree(devResults));
  free(hostResults);

  return 0;
}